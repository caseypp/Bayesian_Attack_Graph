<html>
<title>Influence Diagrams</title>
<link rel="stylesheet" type="text/css" href="css/table.css">
<body>
<table width = "100%">
	<tr><td width="100%" bgcolor="#0000ff"><h2><font color="ffffff">One of the inference methods in LIMIDs</font></h2></td></tr>
	<tr><td><p><font class="method">Policies and strategies</font></p>
		<p>A pure policy for decision node <i>d</i> prescribes an alternative in the set of all possible values for each possible configuration of its parents <i>pa(d)</i>.The designation for a node <i>d</i> policy is <img src="formulas/1.gif">.  To allow for possible randomization we consider more general policies represented by functions on the set of all possible values of node <i>d</i> and set of all possible configurations of it’s parents <i>pa(d)</i> Cartesian product. This function represent a probability distribution over alternative choices of d  for each possible configuration of <i>pa(d)</i>.</p>
		<p>A <i>strategy</i> for a LIMID is a set of policies for each decision node. A pure strategy is a set of pure policies. If a strategy is not pure it is called <i>random</i>.</p>
		<p>A <i>global maximum strategy Q</i> is a strategy which satisfies <i>E(U(Q)) >= E(U(q))</i> for all strategies <i>q</i>.</p>
		<p>If our main goal is to maximize the mathematical expectation of the income, we have to find a strategy which satisfies <i>E(U(Q)) >= E(U(q))</i> for all strategies <i>q</i>. </p>
		<p><font class="method">Local maximum strategy and income expectation</font></p>
		<p>For each strategy <img src="formulas/2.gif"> and any decision node <i>d0</i> we will define <img src="formulas/3.gif">. Now let <img src="formulas/4.gif"> (we simply changed policy <img src="formulas/5.gif"> to policy <img src="formulas/6.gif">)</p>
		<p>A <i>local maximum policy</i> for a strategy <i>q</i> at <i>d</i> decision node is a policy <img src="formulas/7.gif"> which satisfies</p>
		<p><img src="formulas/8.gif"></p>
		<p>A strategy <img src="formulas/9.gif"> is said to be a local maximum strategy if all its policies are local maximum policies, i.e. if for all decision nodes <i>d</i> and all policies <img src="formulas/1.gif"> we have <img src="formulas/10.gif">.</p>
		<p><font class="method">Single policy updating</font></p>
		<p>This subsection describes an iterative procedure for improving strategies within LIMIDs termed <i>Single Policy Updating (SPU)</i>. From an initial strategy <i>q<sup>0</sup></i>  it updates each policy in some order.</p>
		<p>Assume that the current strategy is <i>q<sup>l</sup></i> and that the policy for <i>d<sub>0</sub></i> is to be updated. Then the next strategy <i>q<sup>l+1</sup></i> only differs from <i>q<sup>l</sup></i> on the policy for <i>d<sub>0</sub></i> and it is generated by finding a local maximum policy <img src="formulas/11.gif"> for <i>q<sup>l</sup></i> and <i>d<sub>0</sub></i> at and letting <img src="formulas/12.gif">.</p>
		<p>When all the policies have been updated once we say that one <i>cycle</i> has been performed. The algorithm stops if the expected utility of strategies generated in two successive cycles is unaltered.</p>
		<p>A few comments are in place here:</p>
		<ul>
			<li>The initial strategy <i>q<sup>0</sup></i>  may be random and it is typically advantageous to choose it as such</li>
			<li>There is always a pure local maximum policy <img src="formulas/11.gif">, however it may not be unique.</li>
		</ul>
		<p>If we always choose a pure local maximum policy in each step, the algorithm eventually reaches a local maximum strategy at which no progress is made. This holds because there is only a finite number of pure strategies and the expected utility increases at each cycle. These observations are stated formally below.</p>
		<p><b>Iterative improvement</b><i> SPU is an iterative improvement algorithm: after each cycle, the expected utility of the current strategy has increased or is unaltered. In the latter case, the algorithm has reached a local maximum strategy.</i></p>
		<p><b>Convergence</b><i> SPU converges to a local maximum strategy if we always choose a pure policy in each updating step. In this case the algorithm converges in a finite number of cycles.</i></p>	
		<p>We shall later discuss how to choose initial strategies, updating sequences, and give conditions ensuring local maximum strategies to be global maximum strategies.</p>
		<p><font class="method">Potentials and their operations</font></p>
		<p>In our local computation algorithms we represent the quantitative elements of a LIMID through entities called potentials. Each such potential has two parts as detailed below.</p>
		<p>Let <i>W</i> be a subset of chance and decision nodes. Then a Potential on <i>W</i> is a pair <img src="formulas/13.gif"> of real-valued functions on the set of all values of nodes from set <i>W</i>,  and <i>p<sub>w</sub></i> is non-negative.</p>
		<p>The first part <i>p<sub>w</sub></i> of the potential is called the <i>probability part</i>, and the second part <i>u<sub>w</sub></i> is called the <i>utility part</i>. We call the probability part vacuous if it is equal to unity, and the utility part is vacuous if it is identically equal to zero.</p>
		<p>We identity two potentials <img src="formulas/14.gif"> and <img src="formulas/15.gif"> on <i>W</i> and write <img src="formulas/16.gif"> if <img src="formulas/17.gif"> and <img src="formulas/18.gif"> whenever <img src="formulas/19.gif">, i.e. two potentials are considered equal if they have identical probability parts and their utility parts agree almost surely with respect to the probability parts.</p>
		<p>Let <img src="formulas/20.gif"> and <img src="formulas/21.gif"> be two potentials on <i>W<sub>1</sub></i> and <i>W<sub>2</sub></i> respectively. The combination <img src="formulas/22.gif"> of <img src="formulas/23.gif"> and <img src="formulas/24.gif"> is the potential on <img src="formulas/25.gif"> given by</p>
		<p><img src="formulas/26.gif"></p>
		<p>Let <img src="formulas/13.gif"> be a potential on <i>W</i>, and let <img src="formulas/27.gif">. The marginalization <img src="formulas/28.gif"> of <img src="formulas/29.gif"> onto <i>W<sub>1</sub></i>  is the potential on <i>W<sub>1</sub></i> given by </p>
		<p><img src="formulas/30.gif"></p>
		<p>The division operation in the utility part is necessary to preserve expected utilities. The convention 0/0=0  has been used here and throughout.</p>
		<p><font class="method">Inference engine based on Junction tree</font></p>
		<p>As mentioned, our algorithm proceeds by message passing in a suitable computational structure known as a junction tree. In the present subsection we describe how to construct this junction tree.</p>
		<p>As for similar local computation algorithms the construction involves first a moralization process, in which an undirected graph is constructed, then a triangulation, where additional edges are added, and finally the organization of the cliques of the triangulated graph into a junction tree.</p>
		<p>The transformation from the LIMID <i>L</i> to an undirected graph is made by first adding undirected edges between all nodes with a common child (including children that are value nodes). As value nodes do not have children, only edges between chance or decision nodes are added. Then we drop the directions on all arcs and finally remove all value nodes. The resulting ‘moral’ graph is denoted by <i>L<sup>m</sup></i>.</p>
		<p>Next, edges are added to the undirected graph <i>L<sup>m</sup></i> to form a triangulated graph <img src="formulas/31.gif">. The moral graph is triangulated so no additional edges are needed.</p>
		<p><img src="figure_3.gif"></p>
		<p>After the moralization, we have to delete all utility nodes from graph.</p>
		<p>Finally the cliques <i>C</i> of <img src="formulas/31.gif"> are organized into a junction tree <i>T</i> having the property that for any node from the set of chance and division nodes, the collection of all cliques containing this node correspond to a connected subtree of <i>T</i>. </p>
		
		<p><font class="method">Steps of algorithm</font></p>
		<p><b>Initialization</b></p>
		<p>Suppose we are given a LIMID <i>L</i> and the initial strategy <img src="formulas/2.gif">. To initialize the junction tree <i>T</i> one first associates a vacuous potential to each clique <img src="formulas/32.gif">. Then for each chance node <i>r</i> in <i>L</i>, <i>p<sub>r</sub></i> is multiplied onto the probability part of the potential of an arbitrary clique containing <i>fa(r)</i>. When this has been done, one takes each value node u and adds <i>U<sub>u</sub></i> to the utility part of the potential of any clique containing <i>pa(u)</i>.</p>
		<p>Let <img src="formulas/33.gif"> be the potential on clique <i>C</i> after these operations have been performed. The joint potential is equal to the combination of all the clique potentials and satisfies</p>
		<p><img src="formulas/34.gif"></p>
		<p>where Ã - set of chance nodes, <img src="formulas/35.gif"> - set of decision nodes, <img src="formulas/36.gif"> - set of utility nodes.</p>
		<p><b>Collect propagation</b></p>
		<p>Let <img src="formulas/37.gif"> be a collection of potentials on the junction tree <i>T</i>. Let <img src="formulas/38.gif"> and suppose we wish to find the marginal <img src="formulas/39.gif"> for some clique <img src="formulas/40.gif">.</p>
		<p>To achieve our purpose we direct all the edges in <i>T</i> towards the ‘root-clique’ <img src="formulas/41.gif">. Then each clique passes a message to its child after having received messages from all its other neighbours. The structure of a message <img src="formulas/42.gif"> from clique <i>C<sub>1</sub></i> to its neighbor <i>C<sub>2</sub></i> is given by</p>
		<p><img src="formulas/43.gif"></p>
		<p><b>Local optimization</b></p>
		<p>Let <img src="formulas/13.gif"> be a potential. The contraction of <img src="formulas/29.gif"> is given as <img src="formulas/44.gif">. </p>
		<p><b>Theorem:</b> For a potential <img src="formulas/13.gif"> on <i>W</i> and <img src="formulas/27.gif"> we have </p>
		<p><img src="formulas/45.gif"></p>
		<p><b>Corollary:</b> Let the joint potential <img src="formulas/46.gif"> on the junction tree be given by</p>
		<p><img src="formulas/47.gif"></p>
		<p>where <img src="formulas/2.gif"> is a strategy. Then the expected utility of <i>q</i> is <img src="formulas/48.gif"></p>
		<p><br>So, a local maximum policy for strategy q at d can be found by carrying out the following steps:</p>
		<ol>
			<li><b>Retract:</b> Retract the policy for d from the potential on <i>R</i> to obtain <img src="formulas/49.gif">.</li>
			<li><b>Collect:</b> Collect to <i>R</i> to obtain <img src="formulas/50.gif">.</li>
			<li><b>Marginalize:</b> Compute <img src="formulas/51.gif">.</li>
			<li><b>Contract:</b> Compute the contraction <i>c<sub>fa(d)</sub></i> of <img src="formulas/52.gif">.</li>
			<li><b>Optimize:</b> For each <img src="formulas/53.gif">, find a point <img src="formulas/54.gif"> satisfying <img src="formulas/55.gif"> and define <img src="formulas/56.gif"> as the distribution degenerate at <img src="formulas/54.gif">. Add <img src="formulas/57.gif"> to the potential on <i>R</i> to get <img src="formulas/58.gif">.</li>
		</ol>
	</td></tr>
</table>
</body>
</html>